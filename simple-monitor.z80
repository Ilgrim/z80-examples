;;
;; Simple monitor program.
;;
;; Accept strings from STDIN, and execute them.
;;
;; Built-in commands
;;
;;   [c]all xxxx  -> Call the routine at XXXX
;;
;;   [d]ump       -> Dump 16 bytes of RAM at a given address.
;;
;;   [i]nput      -> Enter bytes
;;
;;   [q]uit       -> Halt the CPU
;;

org 0

;;
;; Entry-point to the monitor.
;;
;; Read text into into `input_buffer`, appending to the buffer until a newline
;; is seen, then invoke `process` to handle the input.
;;
monitor:
        ; show the prompt.
        ld hl, prompt_string
        call print_string

        ; Ensure that the input-buffer is empty to avoid previous
        ; input bleeding into future input.
        ld hl, input_buffer
        push hl
        ld a, '\n'
        ld b, 80
   fill_input_buffer:
        ld (hl),a
        inc hl
        djnz fill_input_buffer
        pop hl

        ; Read characters and append them to the `input_buffer` region
        ; until we receive a newline or a failure to read more.
        ;
        ; If the buffer is complete then jump to the `process_input_line`
        ; code to run the appropriate command.
input_loop:
        in a,(1)
        cp '\n'
        jr z, process_input_line
        ld (hl),a
        inc hl
        jr input_loop



;;
;; process_input_line is called when the monitor has received a complete
;; newline-terminated line of text.
;;
;; We process the contents by looking for commands we understand, if we see
;; input we don't recognize we show a message and return, otherwise we invoke
;; the appropriate handler.
;;
;;  C => CALL
;;  D => DUMP
;;  I => INPUT
;;
process_input_line:

        ld hl, input_buffer
        ld a, (hl)

        ; C == CALL
        cp 'c'
        jr z, call_handler
        cp 'C'
        jr z, call_handler

        ; D == DUMP
        cp 'd'
        jr z, dump_handler
        cp 'D'
        jr z, dump_handler

        ; I == INPUT
        cp 'i'
        jr z, input_handler
        cp 'I'
        jr z, input_handler

        ; Q == QUIT
        cp 'q'
        jr z, quit_handler
        cp 'Q'
        jr z, quit_handler

        ; Unknown command: show a message and restart our monitor
        ld hl, unknown_command_string
        call print_string
        jr monitor




;;
;; Call is invoked with the address to call
;;
;; For example "C0003" will call the routine at 0x0003
;;
call_handler:
        ld hl, input_buffer
        inc hl

        ; Read the address to call into BC
        call read_16_bit

        ; We'll be making a call, so we need to have the return
        ; address on the stack - so that when the routine ends
        ; execution goes somewhere sane.
        ;
        ; We'll want to re-load the monitor, so we'll store the
        ; entry point on the stack
        ld hl, monitor
        push hl

        ; Now we call, indirectly, the address in the BC register.
        push bc
        ret



;;
;; Dump 16 bytes from the current dump_address
;;
;; We're called with either "D" to keep going where we left off or
;; "D1234" if we should start at the given offset.
;;
dump_handler:

        ; Our input-buffer will start with [dD], so we start looking at the
        ; next character.
        ld hl, input_buffer+1

        ; Look at the next input-byte.  If empty then no address.
        ld a, (hl)
        cp '\n'
        jr z, dump_handler_no_number

        ; OK we expect an (ASCII) address following HL.
        ; Read it into BC.
        call read_16_bit
        ld (dump_address), bc

dump_handler_no_number:
        ; The address we start from
        ld hl, (dump_address)
        ; show the address
        call DispHLhex

        ; Loop to print 16-bytes
        ld b, 16
dump_byte:
        ; show a space
        ld a, ' '
        out (1), a

        ; show the memory-contents.
        ld c, (hl)
        call OutHex8
        inc hl
        djnz dump_byte

        ; all done
        ld a, '\n'
        out (1),a

        ; store our updated/final address.
        ld (dump_address), hl
        jp monitor



;;
;; Input handler allows code to be assembled at a given address
;;
;; Usage is:
;;
;;  I01234 01 02 03 04 0f
;;
;; i.e. "I<address> byte1 byte2 .. byteN"
;;
;; If there is no address keep going from the last time, which means this
;; works as you expect:
;;
;;   I1000 01 03
;;   I 03 04 0F
;;
input_handler:
        ; Our input-buffer will start with [iI], so we start looking at the
        ; next character.
        ld hl, input_buffer+1

        ; Look at the next input-byte.  If it is a space then no address was
        ; given, so we keep appending bytes to the address set previously.
        ld a, (hl)
        cp ' '
        jr z, input_handler_no_address

        ; OK we expect an (ASCII) address following HL - Read it into BC.
        call read_16_bit
        ld (input_address), bc

input_handler_no_address:

        ;; HL contains the a string.  Get the next byte
        ld a,(hl)
        inc hl

        ; space? skip
        cp ' '
        jr z, input_handler_no_address

        ; newline? If so we're done
        cp '\n'
        jp z, monitor

        ; OK then we have a two-digit number
        dec hl
        call Read8bit

        ; store the byte in RAM
        ld bc, (input_address)
        ld (bc), a

        ; bump to the next address
        inc bc
        ld (input_address), bc

        ; continue
        jr input_handler_no_address


;;
;; Invoked to quit; this just shuts down the processor.
;;
quit_handler:
        halt



;;
;; Convert a 4-digit ASCII number, pointed to by HL to a number.
;; Return that number in BC.
;;
read_16_bit:
	; HL is a pointer to a four-char string
	; This is read as a 16 bit hex number
	; The number is stored in BC
	call		Read8bit
	ld		b, a
	call		Read8bit
	ld		c, a
	ret





;;
;; HL is a pointer to a two-char string
;; This is read as an 8 bit hex number
;; The number is stored in A
;;
Read8bit:
	ld		a, (hl)		; Copy first char to A

        ; is it lower-case?  If so upper-case it.
        cp 'a'
        jr c, Read8BitUC
        cp 'z'
        jr nc, Read8BitUC
        sub a, 32
Read8BitUC:
        call		Hex12		; Convert first char
        add		a, a		; Multiply by 16...
        add		a, a		; ...
        add		a, a		; ...
        add		a, a		; ...done!
        ld		d, a		; Store top 4 bits in D
	inc		hl		; Advance to next char
        ld		a, (hl)
        call		Hex12		; Convert second char
        or		d		; Add back top bits
	inc		hl		; Advance for next guy
        ret
Hex12:	sub		a, '0'
        cp		10
        ret		c
        sub		a,'A'-'0'-10
        ret


;
; Display the 16-bit number stored in HL
;
DispHLhex:

   ld  c,h
   call  OutHex8
   ld  c,l
   call OutHex8
   ret

;
; Display the 8-bit number stored in C
;
OutHex8:
   ld  a,c
   rra
   rra
   rra
   rra
   call  Conv
   ld  a,c
Conv:
   and  $0F
   add  a,$90
   daa
   adc  a,$40
   daa
   ; Show the value.
   out (1),a
   ret


;;
;; Print String
;;
print_string:
   ld a,(hl)
   inc hl
   cp '$'
   ret z
   out (1),a
   jr print_string



;;;;;;;;
;;;;;;;; RAM stuff
;;;;;;;;

;;
;; Unknown command message
;;
unknown_command_string:
        db "Unknown command.\n$"

;;
;; The string we print as the users' prompt
;;
prompt_string:
        db ">$"

;;
;; We track of the address from which we dump RAM here.
;;
dump_address:
   db 0,0

;;
;; Keep track of where we input bytes to.
;;
input_address:
   db 0,0


;;
;; This is where we read a line of input
;;
;; There is no upper-limit here, though in practice we only reset the first 80
;; bytes with newlines.
;;
input_buffer:

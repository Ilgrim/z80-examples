;;
;; Simple monitor program.
;;
;; Accept strings from STDIN, and execute them.
;;
;; Built-in commands
;;
;;   call xxxx  -> Call the routine at XXXX
;;
;;   dump       -> Dump 16 bytes of RAM - each time you call it you get
;;                 16 more bytes
;;
;;   input      -> Enter bytes
;;
;;

org 0

;;
;; Jump to the monitor
;;
jp monitor



;;
;; Test-code.  This is a simple subroutine which is assembled at a fixed
;; address so that we can CALL it, via the C-function, as a test.
;;
;; This code will be located at address 0x0003, invoke it with C0003
;;
    ld hl, i_called
    call print_string
    ret

   i_called:
     db "This was a subroutine call at 0x2000\n$"


;;
;; Monitor is our entry-point
;;
;; Read a line of input into the fixed-buffer located at `input_buffer`.
;;
;; Keep appending to the buffer until we see a newline, and once we reach
;; that invoke `process` to handle it.
;;
monitor:
        ; show a prompt.
        ld a, '\n'
        out (1), a
        ld a, '>'
        out (1), a

        ; We read input here.
        ld hl, input_buffer

        ; but first of all reset it
        push hl
        ld a, '\n'
        ld b, 16
   empty_ram:
        ld (hl),a
        inc hl
        djnz empty_ram
        pop hl

input_loop:
        ; read a character
        in a,(1)
        ; eof?
        cp -1
        jp z, process_input_line
        cp '\n'
        jp z, process_input_line
        ; otherwise store
        ld (hl),a
        inc hl
        jp input_loop



;;
;; process_input_line is called when the monitor has received a complete
;; newline-terminated line of text.
;;
;; We process the contents by looking for commands we understand, if we see
;; input we don't recognize we show a message and return, otherwise we invoke
;; the appropriate handler.
;;
;;  C => CALL
;;  D => DUMP
;;  I => INPUT
;;
process_input_line:

        ld hl, input_buffer
        ld a, (hl)

        ; C == CALL
        cp 'c'
        jp z, call_handler
        cp 'C'
        jp z, call_handler

        ; D == DUMP
        cp 'd'
        jp z, dump_handler
        cp 'D'
        jp z, dump_handler

        ; I == INPUT
        cp 'i'
        jp z, input_handler
        cp 'I'
        jp z, input_handler

        ; Unknown command.
        ld hl, unknown_command
        call print_string
        jp monitor




;;
;; Call is invoked with the address to call
;;
;; For example "C0003" will call the routine at 0x0003
;;
call_handler:
        ld hl, input_buffer
        inc hl

        ; address follows HL
        call read_16_bit

        ; bc has the address to call.
        ; we push our "return address", and jump
        ld hl, monitor
        push hl
        push bc
        ret



;;
;; Dump 16 bytes from the current dump_address
;;
;; We're called with either "D" to keep going where we left off or
;; "D1234" if we should start at the given offset.
;;
dump_handler:

        ; Input buffer will start with [Dd]
        ld hl, input_buffer
        inc hl

        ; Look at the next input-byte.  If empty then no address.
        ld a, (hl)
        cp '\n'
        jp z, dump_handler_no_number
        cp 0
        jp z, dump_handler_no_number

        ; OK we expect an (ASCII) address following HL.
        ; Read it into BC.
        call read_16_bit
        ld (dump_address), bc

dump_handler_no_number:
        ; The address we start from
        ld hl, (dump_address)
        ; show the address
        call DispHLhex
        ; show a space
        ld a, ' '
        out (1), a

        ; We print 16-bytes at a time
        ld b, 16
dump_byte:
        ld c, (hl)
        call OutHex8
        inc hl
        ld a, " "
        out (1), a
        djnz dump_byte
        ld a, '\n'
        out (1),a
        ld (dump_address), hl
        jp monitor



;;
;; Input handler allows code to be assembled at a given address
;;
;; Usage is:
;;
;;  I01234 01 02 03 04 0f
;;
;; i.e. "I<address> byte1 byte2 .. byteN"
;;
;; If there is no address keep going from the last time, which means this
;; works as you expect:
;;
;;   I1000 01 03
;;   I 03 04 0F
;;
input_handler:
        ; Input buffer will start with [iI]
        ld hl, input_buffer
        inc hl

        ; Look at the next input-byte.  If it is a space then no address was
        ; given, so we keep appending bytes to the address set previously.
        ld a, (hl)
        cp ' '
        jp z, input_handler_no_address

        ; OK we expect an (ASCII) address following HL - Read it into BC.
        call read_16_bit
        ld (input_address), bc

input_handler_no_address:

        ;; HL contains the a string.  Get the next byte
        ld a,(hl)
        inc hl

        ; space? skip
        cp ' '
        jp z, input_handler_no_address

        ; newline/null? we're done
        cp '\n'
        jp z, monitor
        cp 0
        jp z, monitor

        ; OK then we have a two-digit number
        dec hl
        call Read8bit

        ; store the byte in RAM
        ld bc, (input_address)
        ld (bc), a

        ; bump to the next address
        inc bc
        ld (input_address), bc

        ; continue
        jp input_handler_no_address





;;
;; Convert a 4-digit ASCII number, pointed to by HL to a number.
;; Return that number in BC.
;;
read_16_bit:
	; HL is a pointer to a four-char string
	; This is read as a 16 bit hex number
	; The number is stored in BC
	call		Read8bit
	ld		b, a
	call		Read8bit
	ld		c, a
	ret





;;
;; HL is a pointer to a two-char string
;; This is read as an 8 bit hex number
;; The number is stored in A
;;
Read8bit:
	ld		a, (hl)		; Copy first char to A

        ; is it lower-case?  If so upper-case it.
        cp 'a'
        jp c, Read8BitUC
        cp 'z'
        jp nc, Read8BitUC
        sub a, 32
Read8BitUC:
        call		Hex12		; Convert first char
        add		a, a		; Multiply by 16...
        add		a, a		; ...
        add		a, a		; ...
        add		a, a		; ...done!
        ld		d, a		; Store top 4 bits in D
	inc		hl		; Advance to next char
        ld		a, (hl)
        call		Hex12		; Convert second char
        or		d		; Add back top bits
	inc		hl		; Advance for next guy
        ret
Hex12:	sub		a, '0'
        cp		10
        ret		c
        sub		a,'A'-'0'-10
        ret


;
; Display the 16-bit number stored in HL
;
DispHLhex:

   ; show "0x" as a prefix
   ld a, '0'
   out(1),a
   ld a, 'x'
   out(1),a

   ld  c,h
   call  OutHex8
   ld  c,l
   call OutHex8
   ret

;
; Display the 8-bit number stored in C
;
OutHex8:
   ld  a,c
   rra
   rra
   rra
   rra
   call  Conv
   ld  a,c
Conv:
   and  $0F
   add  a,$90
   daa
   adc  a,$40
   daa
   ; Show the value.
   out (1),a
   ret


;;
;; Print String
;;
print_string:
   ld a,(hl)
   inc hl
   cp '$'
   ret z
   out (1),a
   jp print_string



;;;;;;;;
;;;;;;;; RAM stuff
;;;;;;;;

;;
;; Unknown command message
;;
unknown_command:
        db "Unknown command.\n$"

;;
;; Keep track of where we DUMP RAM from.
;;
dump_address:
   db 0,0

;;
;; Keep track of where we input bytes to
;;
input_address:
   db 0,0


;;
;; This is where we read a line of input
;;
;; Random size is random.
;;
input_buffer:
        db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

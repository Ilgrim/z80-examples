;;
;; Simple monitor program.
;;
;; Accept strings from STDIN, and execute them.
;;
;; Built-in commands
;;
;;   call xxxx  -> Call the routine at XXXX
;;
;;   dump       -> Dump 16 bytes of RAM - each time you call it you get 16 more bytes
;;
;;   TODO:
;;     input      -> Enter bytes
;;
;;

org 0

;;
;; Jump to the monitor
;;
jp monitor



;;
;; HELPER!
;;
;; This is code at 0x0003
;;
;; It can be tested via "C0003"
;;
;;
    ld hl, i_called
    call print_string
    ret

   i_called:
     db "This was a subroutine call at 0x2000\n$"


;;
;; Monitor is our entry-point
;;
;; Read a line of input - terminating on newline - and process it.
;;
;; We look for (C)all and (D)ump instructions.
;;
;; TODO:
;;  (E)nter
;;
monitor:
        ; show a prompt.
        ld a, '\n'
        out (1), a
        ld a, '>'
        out (1), a

        ; We read input here.
        ld hl, input_buffer

        ; but first of all reset it
        push hl
        ld a, '\n'
        ld b, 16
   empty_ram:
        ld (hl),a
        inc hl
        djnz empty_ram
        pop hl

input_loop:
        ; read a character
        in a,(1)
        ; eof?
        cp -1
        jp z, process_input_line
        cp '\n'
        jp z, process_input_line
        ; otherwise store
        ld (hl),a
        inc hl
        jp input_loop



;;
;; When this routine is called HL points to a string with a newline terminator.
;;
;; We need to work out which routine to call - we do this by looking for a single-character:
;;
;;  C => CALL
;;
;;  D => DUMP
;;
;;  I => INPUT
;;
process_input_line:

        ld hl, input_buffer
        ld a, (hl)

        ; C == CALL
        cp 'c'
        jp z, call_handler
        cp 'C'
        jp z, call_handler

        ; D == DUMP
        cp 'd'
        jp z, dump_handler
        cp 'D'
        jp z, dump_handler

        ; Nothing known.
        ld hl, unknown_command
        call print_string
        jp monitor




;;
;; Call is invoked with the address to call
;;
;; For example "C0003" will call the routine at 0x0003
;;
call_handler:
        ld hl, input_buffer
        inc hl

        ; address follows HL
        call read_16_bit

        ; bc has the address to call.
        ; we push our "return address", and jump
        ld hl, monitor
        push hl
        push bc
        ret



;;
;; Dump 16 bytes from the current dump_address
;;
;; We're called with either "D" to keep going where we left off or "D1234" if we should start at the given offset.
;;
dump_handler:
        ld hl, input_buffer
        inc hl
        ld a, (hl)
        cp '\n'
        jp z, dump_handler_no_number
        cp 0
        jp z, dump_handler_no_number

        ; address follows HL
        call read_16_bit
        ld (dump_address), bc

dump_handler_no_number:
        ; The address we start from
        ld hl, (dump_address)
        ; show the address
        call DispHLhex
        ; show a space
        ld a, ' '
        out (1), a

        ; We print 16-bytes at a time
        ld b, 16
dump_byte:
        ld c, (hl)
        call OutHex8
        inc hl
        ld a, " "
        out (1), a
        djnz dump_byte
        ld a, '\n'
        out (1),a
        ld (dump_address), hl
        jp monitor






;;
;; Convert a four-digit ASCII number, pointed to by HL to a number.
;;
;; Return that number in BC.
;;
read_16_bit:
	; HL is a pointer to a four-char string
	; This is read as a 16 bit hex number
	; The number is stored in BC
	call		Read8bit
	ld		b, a
	call		Read8bit
	ld		c, a
	ret





;;
;; HL is a pointer to a two-char string
;; This is read as an 8 bit hex number
;; The number is stored in A
;;
Read8bit:
	ld		a, (hl)		; Copy first char to A
        call		Hex12		; Convert first char
        add		a, a		; Multiply by 16...
        add		a, a		; ...
        add		a, a		; ...
        add		a, a		; ...done!
        ld		d, a		; Store top 4 bits in D
	inc		hl		; Advance to next char
        ld		a, (hl)
        call		Hex12		; Convert second char
        or		d		; Add back top bits
	inc		hl		; Advance for next guy
        ret
Hex12:	sub		a, '0'
        cp		10
        ret		c
        sub		a,'A'-'0'-10
        ret


;
; Display the 16-bit number stored in HL
;
DispHLhex:

   ; show "0x" as a prefix
   ld a, '0'
   out(1),a
   ld a, 'x'
   out(1),a

   ld  c,h
   call  OutHex8
   ld  c,l
   call OutHex8
   ret

;
; Display the 8-bit number stored in C
;
OutHex8:
   ld  a,c
   rra
   rra
   rra
   rra
   call  Conv
   ld  a,c
Conv:
   and  $0F
   add  a,$90
   daa
   adc  a,$40
   daa
   ; Show the value.
   out (1),a
   ret


;;
;; Print String
;;
print_string:
   ld a,(hl)
   inc hl
   cp '$'
   ret z
   out (1),a
   jp print_string



;;;;;;;;
;;;;;;;; RAM stuff
;;;;;;;;

;;
;; Unknown command message
;;
unknown_command:
        db "Unknown command.\n$"

;;
;; Keep track of where we DUMP RAM from.
;;
dump_address:
   db 0,0


;;
;; This is where we read a line of input
;;
;; Random size is random.
;;
input_buffer:
        db 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
